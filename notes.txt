what is CDN?
what is cross-origin?
React element is an object, that aa browser understands.
Package.json is a configuration for npm.
The most important package in our project is bundler... bundling all independent files and running as once
In our project, we will use Parcel..(just bcz it is easy to install)... all webpacks are almost same.

npm i -D parcel
what does -D? I want it as a dev dependencies
There are 2types of dependencies we can install
1)Dev dependencies - uesd in dev
2)Normal dependencies - used in production also
The tilde ~ is used when you only want bug fixes and minor improvements that won't break existing functionality within the current minor version.
The caret ^ is used when you want to receive new features and bug fixes within the same major version, assuming they maintain backward compatibility. 

difference betn package.json and package-lock.json
package-lock.json keeps a track of every version update has has exact lataest version, but package.json keeps only minor version updates
node modules are created contain all the database of all dependencies that we need.
Node modules contain all the code of npm, hence it should be added to git to get smooth prod code running
to avoid going files to git, add them in file named gitignore
transitive dependency: parcel needs lot more packages to run.. which in return install all other libs also
Whatever we can recreate we should never put that on git.
do we need to push package, package.json files also to github?
yes.. because it has all the dependency file that our project needs to run
if u have then, u can recreate all the node modules




#Parcel (parcels.org)
Dev Build
Localserver
HMR (Hot Module Replacement)
File watching Algorithm(writtten in c++)
Caching- Faster builds
Image Optimization as well
Minification\
bundling
Compresssing
consistent Hashing
code Splitting
Differential Bundling- Support older browsers
Diagnostics
Error Handling
HTTPS
Tree shaking- remove unused code

Whether u should put parcel-cache and dist in github... no.. they are automatically created on build.. no need


"start": "parcel index.html"------> used to create dev build
"build" : "npx build index.html" ---> used to create prod build

Note: If u are new to language, proj and dont know how to execute program : 
goto package.json> scripts> here u will find the code to run

so , npm start = npm run starts--> it craetes a dev build for used(parcel executes it behind the scene as we put in package.json)
npm run build---> creates  a prod build

JSX- It is NOT a HTML code inside JS, It is HTML-like/ XML-like syntax inside JS.
In JSX, if u have to give attributes to the tag, we use camelCase.
HomeWork: Try to explore different tags of HTML(img, p, a href) , to write JSX code


//React.createElement => ReactElement - JS Object => HTMLElement(render)
//JSX is transpiled before it reaches the JS by Parcel -> Babel
 //JSX => Babel transpiles it to React.createElement => ReactElement- JSObject => HTMLElement(render)
Class based components-  not in use
Functional Components- new and easy way to use in React

U can inject any JS inside ur {}in HMTL tag in JSX.
We can use Element insideFunctin, Function inside elememt, element inside element... at the end its all JS...
We can plau around
ex:const Title= () =>(
    <h1 className="head" tabIndex="5">
        Namaste React using JSX
    </h1>
 );


 //Component Composition
 const HeadingComponent= ()=>(
 <div id="container">
    <Title/>
    {Title()}
    <Title></Title>
    <h1 className="heading">Namaste React Functional Component</h1>
 </div>);

When u want to pass a dynamic data to a component then u passs it as a prop(arguments in JS)


    Lets start making a Food Ordering App like Swiggy , Zpmato
    So, lest create an outline..
    Header - logo, navigation bar
    Body- search, restaurant container- restaurant cards-img,cuisines,rating,eta,price...
    Foooter-copyrght, address,links,  contact

    config-driven UI
    taking example of any food ordering app, the UI, cards, offers everything changes location-wise..
    Do we have seperate  website/UI for different plces.. NO.
    We have data-driven UI(Config-Driven UI)
    

    key is important to be rendered with map() bcoz reacts doesnt understand thedata uniqueness.. it can re-render the whole set of data on evry new entry made
    hence we should do this for code optimization

    There are two types of Export/ Import
    -Default Export/ Import
    export default Component;
    import Component from./path

    -NAmed Export/ Import
    export const variable/Component
    import {Component} from "path"

  HomeWork : Can we use Default export with name export Component --I think yes, we cannot use default export twice, so its a mandate to use named export to export 2 components
  It is a good practice to keep ur file code not more than 100line.. If exceeding, there is something wrong in the code, and we need to optimize it

  Whenever a state variable changes, React will re-render the components    

  Reconciliation Algorithm (React Fiber Algo) came in React 16--->

State Change: The state of your app changes because a new item is added.
New Virtual DOM: React creates a new Virtual DOM that includes the new item.
Diff Algorithm: The diff algorithm compares the new Virtual DOM with the old Virtual DOM.
Identify Changes: The algorithm identifies that a new item has been added.
Minimal Updates: React updates the actual DOM to include only the new item, rather than re-rendering the entire list.
The process of comparing the new virtual DOM with the previous one using diff algorithm is called reconciliation.
Benefits of Reconciliation
Faster UI Updates
Minimal DOM Manipulation
Improved User Experience
Smoother Interactions
Responsive Applications
Conclusion
Reconciliation is a core concept that makes React powerful and efficient. The next time you add a new feature to your React app, remember that reconciliation is working behind the scenes to keep everything running smoothly.

React ensures high performance and a better user experience by using the Virtual DOM and the diff algorithm

to update only the changed elements in the real DOM efficiently.

useEffect function is a callback function, and it will only be loadedonce the component is rendered.
Shimmer UI--Shimmer is a temporary animation placeholder for when data from the service call takes time to get back and we don't want to block rendering the rest of the UI.

Link Component is again a super power given by  React .. for routing it doesnt render the whole page.

There are 2 types of Routing in webpages
1) Client side Routing
2) Server side Routing


Why do we use super(props)?
Why we cannot use sync in useEffect?
